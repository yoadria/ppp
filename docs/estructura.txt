este es mi ppp/main.py:
from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run(debug = True, host="0.0.0.0") #Que no sea visible para todo el mundo - para eso usar un host ="0.0.0.0"

ppp/app/__init__.py:
from flask import Flask
from database.conexion import init_db_connection

def create_app():
    app = Flask(__name__)

    # Inicializa la conexión global a la BD
    init_db_connection()
    

    from .routes import main
    app.register_blueprint(main)

    return app

ppp/app/pushover_app.py:
import requests
import logging
import json

logging.basicConfig(
    level=logging.DEBUG,  # Muestra los logs de nivel DEBUG y superior
    format='%(asctime)s - %(levelname)s - %(message)s'  # Formato para mostrar los logs
)

_logging = logging.getLogger(__name__)

# --- ¡IMPORTANTE! Verifica estas claves ---
# Asegúrate de que API_TOKEN sea la clave de tu APLICACIÓN en Pushover
# y USER_KEY sea tu clave de USUARIO personal de Pushover.
# En tu ejemplo anterior parecían estar al revés. Revisa tu dashboard de Pushover.
API_TOKEN = 'aihav4mdzxeey528gkmmaknt75nf81'  # Token de tu Aplicación Pushover
USER_KEY = 'usi8tt5hzn9utn8wv6sq8higcn4pgb'   # Tu User Key de Pushover

# --- Valores para Emergencia ---
# Define cada cuánto se reintenta (mínimo 30 segundos)
SEGUNDOS_REINTENTO = 60  # Ejemplo: Reintentar cada 60 segundos
# Define durante cuánto tiempo se reintentará (máximo 10800 segundos = 3 horas)
# Recuerda el límite de 50 reintentos. Con 60s de reintento, 3600s (1 hora) son 60 reintentos.
# Se limitará a 50 reintentos * 60s = 3000 segundos (50 minutos).
# Si pones retry=30 y expire=10800, se limitará a 50 reintentos * 30s = 1500 segundos (25 minutos).
SEGUNDOS_EXPIRACION = 3600 # Ejemplo: Dejar de reintentar después de 1 hora (efectivamente 50 mins con retry=60)

# Opcional: URL de Callback (debe ser pública y accesible desde internet)
# CALLBACK_URL = "https://tu.servidor.com/api/pushover_callback" # Descomenta y ajusta si la necesitas

def enviar_notificacion_llamada(habitacion, cama):
    """
    Envia una notificación a Pushover indicando una llamada
    desde una habitación y cama específicas.
    """
    # Construye el mensaje deseado usando los parámetros recibidos
    # mensaje = f"Llamada de la cama {habitacion}{cama}" # Opción 1: Más directo
    mensaje = f"Llamada recibida desde la habitación {habitacion}, cama {cama}." # Opción 2: Más descriptivo

    # Crear un tag único para esta llamada específica (útil para cancelar por tag)
    # Ejemplo: "llamada_hab101_camaA"
    tag_llamada = f"llamada_hab{habitacion}_cama{cama}"
    # Datos para la API de Pushover
    data = {
        "token": API_TOKEN,
        "user": USER_KEY,
        "message": mensaje,
        "title": "Llamada entrante",
        "html": 0,          # O 1 si usas HTML simple (<b>, <i>, <u>, <a>, <font>)
        "priority": 2,      # ¡Prioridad de Emergencia!
        "retry": SEGUNDOS_REINTENTO,  # ¡Obligatorio para priority=2!
        "expire": SEGUNDOS_EXPIRACION, # ¡Obligatorio para priority=2!
        "sound": "persistent", # Sonido 'persistent' o 'echo' son buenos para emergencia
                               # 'persistent' suena hasta que se confirma
        "tags": tag_llamada     # Añadir la etiqueta para posible cancelación posterior
        # Descomenta la siguiente línea si usas callback:
        # "callback": CALLBACK_URL,
    }
    receipt_id = None # Para guardar el ID del recibo si la llamada es exitosa

    _logging.debug(f"Enviando datos a Pushover: {data}")
    # Intenta enviar la notificación
    try:
        # Es buena idea añadir un timeout a la petición
        response = requests.post(
            "https://api.pushover.net/1/messages.json",
            data=data,
            timeout=15
        )
        # Verifica si la respuesta de Pushover fue exitosa (código 2xx)
        response.raise_for_status()
        respuesta_json = response.json()
        _logging.debug(f"Respuesta de Pushover: {respuesta_json}")

        # Verifica el estado en la respuesta y obtiene el receipt
        if respuesta_json.get("status") == 1 and "receipt" in respuesta_json:
            receipt_id = respuesta_json["receipt"]
            _logging.info(f"✅ Notificación de EMERGENCIA enviada para Hab: {habitacion}, Cama: {cama}. Receipt ID: {receipt_id}, Tag: {tag_llamada}")
            # --- ¡IMPORTANTE! ---
            # Debes guardar este 'receipt_id' asociado a la llamada original
            # si necesitas verificar su estado o cancelarla más tarde.
            # Por ejemplo, guardarlo en tu base de datos junto al registro de la llamada.
            return receipt_id # Devolver el receipt para que el código que llama lo gestione
        else:
            # Caso raro: HTTP 200 pero la respuesta indica un problema
            error_msg = respuesta_json.get("errors", ["Respuesta inesperada sin errores detallados"])
            _logging.error(f"⚠️ Error lógico de API Pushover para Hab: {habitacion}, Cama: {cama}: {error_msg}")
            return None
        
    except requests.exceptions.RequestException as e:
        _logging.error(f"❌ Error al enviar notificación para Hab: {habitacion}, Cama: {cama}: {e}")
        # Imprimir más detalles si hay una respuesta de error de la API
        if hasattr(e, 'response') and e.response is not None:
            try:
                # Intenta decodificar el cuerpo de la respuesta como JSON
                error_json = e.response.json()
                error_detalle = f"Código: {e.response.status_code}, Errores: {error_json.get('errors', ['N/A'])}"
            except json.JSONDecodeError:
                # Si la respuesta no es JSON válido
                error_detalle = f"Código: {e.response.status_code}, Respuesta (no JSON): {e.response.text}"
            _logging.error(f"   Detalle del error de API Pushover: {error_detalle}")
        return None # Indicar fallo



ppp/app/routes.py:
from flask import Blueprint, render_template, jsonify, request
from database.conexion import get_db_connection
from database.insertar_datos import *
from database.solicitar_datos import *
from .pushover_app import enviar_notificacion_llamada
import logging


logging.basicConfig(
    level=logging.DEBUG,  # Muestra los logs de nivel DEBUG y superior
    format='%(asctime)s - %(levelname)s - %(message)s'  # Formato para mostrar los logs
)

_logging = logging.getLogger(__name__)
main = Blueprint('main', __name__)

# ruta de inicio
@main.route('/')
def index():
    return render_template('index.html')

@main.route('/panel_habitacion')
def panel_habitacion():
    conn = get_db_connection()
    lampara = get_lampara(conn, '101A')
    return render_template('panelhab.html', lampara=lampara)


# ruta para crear asistente post
@main.route('/api/asistente', methods=['POST'])
def crear_asistente():
    data = request.get_json()
    nombre = data.get('nombre')
    codigo_acceso = data.get('codigo_acceso')
    

    if not nombre or not codigo_acceso:
        return jsonify({"mensaje": "Faltan datos"}), 400

   
    datos = {'nombre': nombre, 'codigo':codigo_acceso}
    conn = get_db_connection()
    salida = nuevo_asistente(conn, datos)

    if salida['exito']:
       
        return jsonify({"mensaje": salida}), 201
    else:
       
        return jsonify({"mensaje": salida}), 500

# ruta para crear habitacion post    
@main.route('/api/habitacion', methods=['POST'])
def crear_habitacion():
    data = request.get_json()
    numero = data.get('numero')
    planta = data.get('planta')

    if not numero or not planta:
        return jsonify({"mensaje": "Faltan datos"}), 400

    datos = {'numero': numero, 'planta':planta}
    conn = get_db_connection()
    salida = nueva_habitacion(conn, datos)

    if salida['exito']:
        
        return jsonify({"mensaje": salida}), 201
    else:
       
        return jsonify({"mensaje": salida}), 500
    

# ruta para crear cama post    
@main.route('/api/cama', methods=['POST'])
def crear_cama():
    data = request.get_json()
    codigo = data.get('codigo')
    id_habitacion = data.get('id_habitacion')

    if not codigo or not id_habitacion:
        return jsonify({"mensaje": "Faltan datos"}), 400

    
    datos = {'codigo': codigo, 'id_habitacion':id_habitacion}
    conn = get_db_connection()
    salida = nueva_cama(conn, datos)

    if salida['exito']:
       
        return jsonify({"mensaje": salida}), 201
    else:
        
        return jsonify({"mensaje": salida}), 500
    


@main.route('/llamada/<int:habitacion>/<string:cama>', methods=['GET'])
def llamada(habitacion, cama):
    # import wdb; wdb.set_trace()
    conn = get_db_connection()
    existe_llamada = get_existe_llamada(conn, cama)

    # se realiza consulta con exito
    if existe_llamada['exito']: 

        # hay una llamada activa no hace nada   
        if existe_llamada['mensaje'] != None:
            # return jsonify({'status': 'ok', 'mensaje': f'Llamada ya registrada para habitación {habitacion}, cama {cama}'}), 200
            _logging.debug("hay una llamada en espera")
            return jsonify({'status': 'ok', 'mensaje': f'ya hay una llamada realizada'}), 200

        #no existe la llamada
        else:
            _logging.info("No hay llamada en espera")
            # se procede a crear llamda    
            salida = crear_llamada(conn, cama)
            # se a creado la llamada con exito
            if salida['exito']:
                receipt_id = enviar_notificacion_llamada(habitacion, cama)
                _logging.debug("ID de respuesta: %s", receipt_id)
                return jsonify({'mensaje': salida}), 200
            #error al crear la llamda
            else:
                return jsonify({"mensaje": salida}), 500
    # error en  la conexion 
    else:
        return jsonify({'status': 'error', 'mensaje': 'Error al consultar la base de datos'}), 500



ppp/compose.yaml:
services:
  mariadb:
    image: mariadb:latest
    container_name: mariadb
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: hospital_call
      MYSQL_USER: admin
      MYSQL_PASSWORD: admin
      TZ: Europe/London
    ports:
      - "3306:3306"
    volumes:
      - mariadb_data:/var/lib/mysql
      - ./initdb:/docker-entrypoint-initdb.d

  nginx:
    image: nginx:latest
    container_name: nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./html:/usr/share/nginx/html:ro

  adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080
  flask_app:
    build: .
    container_name: flask_app
    restart: always
    ports:
      - "5000:5000"
    environment:
      - FLASK_APP=main.py
      - FLASK_ENV=development  # Esto activa el modo desarrollo
      - DB_HOST=mariadb
      - DB_USER=admin
      - DB_PASSWORD=admin
      - DB_NAME=hospital_call
      - WDB_SOCKET_SERVER=wdb
      - WDB_NO_BROWSER_AUTO_OPEN=True
    depends_on:
      - mariadb
    volumes:
      - .:/ppp

  wdb:
    image: kozea/wdb
    ports:
      - "127.0.0.1:5001:1984"
    init: true

volumes:
  mariadb_data:

networks:
  ppp_net:
    driver: bridge

ppp/Dockerfile:
# Usa una imagen de Python liviana
FROM python:3.12.3-slim

# Define el directorio de trabajo
WORKDIR /ppp

# Copia tu proyecto dentro del contenedor
COPY . .

# Instala las librerías necesarias
RUN pip install --no-cache-dir -r /ppp/requirements.txt

# Expone el puerto de Flask
EXPOSE 5000

# Comando para correr l app
CMD ["gunicorn", "--reload", "-w", "4","-t", "4", "-b", "0.0.0.0:5000", "main:app"]

ppp/requirements.txt:
flask
pymysql
gunicorn
pushover
requests
wdb

ppp/nginx/nginx.conf

events {
    worker_connections 1024;  # Número de conexiones que cada proceso worker puede manejar
}

http {
    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://flask_app:5000;  # Nombre del contenedor Flask
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_buffering on;
            proxy_buffer_size 128k;
            proxy_buffers 4 256k;
            proxy_busy_buffers_size 256k;
        }

    }

}

ppp/templates/panelhab.html

<html>
	<head>
		<title>lampara 2</title>
		<meta charset="utf-8">
		<!-- <meta http-equiv="refresh" content="2"> -->
	</head>
	<body style="text-align:center;">
		<button id="conmutador" onclick="llamada()">Llamada</button>
		<br>
		<br>
		<button id="presencia" onclick="presencia()">Presencia</button>
		<br>
		<br>
		{% if lampara==0 %}
			<img id="lampara" src="/static/pic_bulboff.gif">
		{% else %}
			<img id="lampara" src="/static/pic_bulbon.gif">
		{% endif %}
	</body>
</html>
<script type="text/javascript">
	//let estado=0;
	function llamada(){
		fetch('http://localhost:5000/llamada/1/101A') 
			.then(response => response.json()) // Convierte la respuesta en JSON
		}

	function presencia(){
		fetch('http://localhost:5000/presencia/101/A') 
			.then(response => response.json()) // Convierte la respuesta en JSON
	}
</script>
